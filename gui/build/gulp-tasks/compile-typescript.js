'use strict';

/**
 * Compile all typescript files.
 * @module compile-typescript
 * @param {Object} buildOptions Build options.
 * @param {Object} gulp Instance of gulp.
 */
module.exports = function (buildOptions, gulp) {
    const gulpTypescript = require('gulp-typescript');
    const gulpDebug = require('gulp-debug');
    const gulpUglify = require('gulp-uglify');
    const gulpIf = require('gulp-if');
    const gulpSourceMaps = require('gulp-sourcemaps');
    const gulpReplace = require('gulp-replace');
    const path = require('path');
    const async = require('async');
    const gulpConcat = require('gulp-concat');

    return function (cb) {
        // Compile TypeScript
        var compilingFailed = false;
        var uglifyOptions = {
            output: {
                screw_ie8: true
            }
        };
        var onEnd = function (err) {
            if (compilingFailed) {
                cb(new Error('Compiling TypeScript failed.'));
            } else {
                cb(err);
            }
        };
        var onError = function (err) {
            compilingFailed = true;
            this.emit('end');
        };
        var getSourceRoot = function (file) {
            if (buildOptions.isTestCoverage) {
                // Code coverage plugin uses file system to resolve paths
                return null;
            } else {
                // Use relative path
                let filePath = file.path;
                let absoluteSourceAppPath = process.cwd() + buildOptions.sourcesPath.substring(1);
                let relativePath = path.relative(path.dirname(filePath), absoluteSourceAppPath) + '/';
                relativePath = relativePath.replace(/\\/g, '/'); // Replace back slashes with forward slashes
                return relativePath;
            }
        };

        async.series([
            next => {
                // Compile sources
                let paths = [
                    buildOptions.sourcesPath + '**/*.ts',
                    buildOptions.sourcesPath + '**/*.tsx',
                    '!' + buildOptions.sourcesPath + '**/*.d.ts',
                    '!' + buildOptions.libraryPath + '**',
                    '!' + buildOptions.distPath + '**'
                ];
                let tsResult = gulp.src(paths)
                    .pipe(gulpIf(buildOptions.isDebug, gulpSourceMaps.init()))
                    .pipe(gulpTypescript('./tsconfig.json'))
                    .on('error', onError);

                tsResult.js
                    .pipe(gulpDebug({ title: 'TypeScript output' }))
                    .pipe(gulpIf(!buildOptions.isDebug, gulpUglify(uglifyOptions)))
                    .pipe(gulpIf(!buildOptions.isDebug, gulpDebug({ title: 'Uglified output' })))
                    // Add istanbul ignore statements
                    // namespaces generated by TypeScript
                    .pipe(gulpIf(buildOptions.isTestCoverage, gulpReplace(/(^\s*\}\)\()(.*\s+\|\|\s+)(\(.*\s+=\s+\{\}\)\);$)/gmi,
                        '$1 /* istanbul ignore next */ $2 /* istanbul ignore next */ $3')))
                    .pipe(gulpIf(buildOptions.isDebug, gulpSourceMaps.write({ sourceRoot: getSourceRoot })))
                    .pipe(gulp.dest(buildOptions.distPath))
                    .on('end', next);
            },
            next => {
                // Compile test
                let paths = [
                    buildOptions.testPath + '**/*.ts',
                    buildOptions.testPath + '**/*.tsx',
                    '!' + buildOptions.testPath + '**/*.d.ts',
                ];
                let tsResult = gulp.src(paths)
                    .pipe(gulpIf(buildOptions.isDebug, gulpSourceMaps.init()))
                    .pipe(gulpTypescript('./tsconfig.json'))
                    .on('error', onError);

                tsResult.js
                    .pipe(gulpDebug({ title: 'TypeScript output' }))
                    .pipe(gulpIf(buildOptions.isDebug, gulpSourceMaps.write({ sourceRoot: '/test/' })))
                    .pipe(gulp.dest(buildOptions.testPath))
                    .on('end', next);
            }
        ], onEnd);

    };
}
